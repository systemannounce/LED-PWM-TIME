C51 COMPILER V9.60.0.0   MAIN1                                                             04/14/2023 13:18:57 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN1
OBJECT MODULE PLACED IN .\Objects\main1.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main1.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\mai
                    -n1.lst) TABS(2) OBJECT(.\Objects\main1.obj)

line level    source

   1          #include <REGX51.H>
   2          #define uint unsigned int
   3          #define uchar unsigned char
   4          #define delaytime 10 // 延迟时间
   5          #include <intrins.h>
   6          
   7          sbit Buzzer=P2^5;
   8          
   9          unsigned char PWM_COUNT; // 计数
  10          unsigned int HUXI_COUNT; // 占空比更新时间
  11          unsigned char PWM_VLAUE; // 占空比比对值
  12          bit direc_flag; // 占空比更新方向
  13          // 管脚定义
  14          // sbit P2_0 = P2 ^ 0;
  15          // sbit P2_1 = P2 ^ 1;
  16          // sbit P2_2 = P2 ^ 2;
  17          // sbit P2_3 = P2 ^ 3;
  18          // sbit P2_4 = P2 ^ 4;
  19          // sbit P2_5 = P2 ^ 5;
  20          // sbit P2_6 = P2 ^ 6;
  21          // sbit P2_7 = P2 ^ 7;
  22          
  23          uint t = 1 , i = 0 , keycount = 0 , keycurrent = 0 , ti = 0 , current = 0 ,solar = 0;
  24          uint LED[8] = {0}; // 8个led
  25          
  26          // 延迟函数
  27          void delay_ms(unsigned int a)
  28          {
  29   1          unsigned int b;
  30   1          while (a-- != 0)for (b = 0; b < 600; b++);
  31   1      
  32   1      }
  33          void delay(uint s)
  34          {
  35   1          while(s--);
  36   1      }
  37          // 定时，1ms
  38          
  39          void i0_server_(void) interrupt 1
  40          {
  41   1          TH0 = 0xFC;
  42   1          TL0 = 0x18;
  43   1          solar++;
  44   1          if(solar >= 1100)solar =0;
  45   1          if(keycurrent ==4)
  46   1          {
  47   2          if (t >= 9)t = 1;
  48   2          else t++;
  49   2      
  50   2          if (t > LED[0]) // LED0 亮度
  51   2              P2_0 = 1;
  52   2          else
  53   2              P2_0 = 0;
  54   2      
C51 COMPILER V9.60.0.0   MAIN1                                                             04/14/2023 13:18:57 PAGE 2   

  55   2          if (t > LED[1]) // LED1 亮度
  56   2              P2_1 = 1;
  57   2          else
  58   2              P2_1 = 0;
  59   2      
  60   2          if (t > LED[2]) // LED2 亮度
  61   2              P2_2 = 1;
  62   2          else
  63   2              P2_2 = 0;
  64   2      
  65   2          if (t > LED[3]) // LED3 亮度
  66   2              P2_3 = 1;
  67   2          else
  68   2              P2_3 = 0;
  69   2      
  70   2          if (t > LED[4]) // LED4 亮度
  71   2              P2_4 = 1;
  72   2          else
  73   2              P2_4 = 0;
  74   2      
  75   2          if (t > LED[5]) // LED5 亮度
  76   2              P2_5 = 1;
  77   2          else
  78   2              P2_5 = 0;
  79   2      
  80   2          if (t > LED[6]) // LED6 亮度
  81   2              P2_6 = 1;
  82   2          else
  83   2              P2_6 = 0;
  84   2      
  85   2          if (t > LED[7]) // LED7 亮度
  86   2              P2_7 = 1;
  87   2          else
  88   2              P2_7 = 0;
  89   2          }
  90   1          if(keycount != 0)
  91   1          {
  92   2          ti++;
  93   2          if(ti > 60000)ti=0;
  94   2          }
  95   1      
  96   1      
  97   1              if(keycurrent ==3)
  98   1          {
  99   2        PWM_COUNT++;
 100   2        HUXI_COUNT++;
 101   2        if(PWM_COUNT == PWM_VLAUE) // 判断是否到了点亮LED的时候
 102   2          P2 = 0xfe; // 点亮LED
 103   2      
 104   2        if(PWM_COUNT == 10) // 当前周期结束
 105   2        {
 106   3          P2 = 0xff; // 熄灭LED
 107   3          PWM_COUNT = 0;
 108   3          } // 重新计时 
 109   2      
 110   2          if((HUXI_COUNT == 60) && (direc_flag == 0))
 111   2          { // 占空比增加10%
 112   3            HUXI_COUNT = 0;
 113   3            PWM_VLAUE++;
 114   3            if(PWM_VLAUE == 9) // 占空比更改方向
 115   3                      direc_flag = 1;
 116   3          }
C51 COMPILER V9.60.0.0   MAIN1                                                             04/14/2023 13:18:57 PAGE 3   

 117   2      
 118   2          if((HUXI_COUNT == 60) && (direc_flag == 1))
 119   2      
 120   2          { // 占空比减少10%
 121   3            HUXI_COUNT = 0;
 122   3            PWM_VLAUE--;
 123   3            if(PWM_VLAUE == 1) // 占空比更改方向
 124   3              direc_flag = 0;
 125   3          } }
 126   1      
 127   1      }
 128          
 129          void Init_t0(void) // 定时器初始化
 130          {
 131   1          TMOD = 0x01; // 选择方式1
 132   1          TH0 = 0xFC;
 133   1          TL0 = 0x18; // 1ms
 134   1          EA = 1;
 135   1          ET0 = 1;
 136   1          TR0 = 1; // 开始计数
 137   1      }
 138          
 139          
 140          
 141          
 142          
 143          
 144          // void Timer0_Routine() interrupt 3
 145          // {
 146          
 147          // }
 148          
 149          
 150          // void Init_t1(void)
 151          // {
 152          //  TMOD =0x01;
 153          //  TH1 = 0x47; // 定时器溢出值设置，每隔200us发起一次中断。
 154          //  TL1 = 0X47;
 155          //  TR1 = 1; // 定时器0开始计时
 156          //  ET1 = 1; // 开定时器0中断
 157          //  EA = 1; // 开总中断
 158          //  PWM_COUNT = 0;
 159          // }
 160          
 161          
 162          void Buzzer_Delay500us()    //@12.000MHz
 163          {
 164   1        unsigned char i;
 165   1      
 166   1        _nop_();
 167   1        i = 247;
 168   1        while (--i);
 169   1      }
 170          
 171          /**
 172            * @brief  蜂鸣器发声
 173            * @param  ms 发声的时长，范围：0~32767
 174            * @retval 无
 175            */
 176          void Buzzer_Time(unsigned int ms)
 177          {
 178   1        unsigned int i;
C51 COMPILER V9.60.0.0   MAIN1                                                             04/14/2023 13:18:57 PAGE 4   

 179   1        for(i=0;i<ms*2;i++)
 180   1        {
 181   2          Buzzer=!Buzzer;
 182   2          Buzzer_Delay500us();
 183   2        }
 184   1      }
 185          
 186          
 187          void main()
 188          {
 189   1          uint et = 1;
 190   1          // LED[7] = 10;
 191   1          Init_t0();
 192   1          // Init_t1();
 193   1          // for (i = 0; i < 8; i++)LED[i] = i;
 194   1          
 195   1            HUXI_COUNT = 0;
 196   1          PWM_COUNT = 0;
 197   1          PWM_VLAUE = 5;
 198   1          direc_flag = 0;
 199   1          P2 = 0xff; // 默认LED熄灭
 200   1           // 定时器0初始化
 201   1      
 202   1          while (1)
 203   1          {
 204   2              while (P3_1 == 0)
 205   2              {
 206   3                  keycurrent =0;
 207   3                  delay_ms(delaytime);
 208   3                  if (keycount == 2 && et == 1){keycount = 3;et = 0;Buzzer_Time(100);}
 209   3                  if (keycount == 1 && et == 1){keycount = 2;et = 0;Buzzer_Time(100);}
 210   3                  if (keycount == 0 && et == 1){keycount = 1;et = 0;Buzzer_Time(100);}
 211   3                  if (ti > 1000){keycurrent = 4;et = 0;keycount = 0;Buzzer_Time(100);}
 212   3              }
 213   2      
 214   2              et = 1;
 215   2      
 216   2              if(ti >1000)
 217   2              {
 218   3                  if(keycurrent != 4)keycurrent = keycount;
 219   3                  keycount = 0;
 220   3                  ti = 0;
 221   3              }
 222   2              if(keycurrent == 1)
 223   2              {
 224   3                  current++;
 225   3                  if(current <5000)P2 = 0x00;
 226   3                  if(current >10000)
 227   3                  {
 228   4                      P2 = 0xFF;
 229   4                      if(current >15000)current = 0;
 230   4                  }
 231   3              }
 232   2              if(keycurrent == 2)
 233   2              {
 234   3                  current++;
 235   3                  if(current <1000)P2 =~0x01;
 236   3                  if(current >1000 && current <2000)P2 = ~0x02;
 237   3                  if(current >2000 && current <3000)P2 = ~0x04;
 238   3                  if(current >3000 && current <4000)P2 = ~0x08;
 239   3                  if(current >4000 && current <5000)P2 = ~0x10;
 240   3                  if(current >5000 && current <6000)P2 = ~0x20;
C51 COMPILER V9.60.0.0   MAIN1                                                             04/14/2023 13:18:57 PAGE 5   

 241   3                  if(current >6000 && current <7000)P2 = ~0x40;
 242   3                  if(current >7000 && current <8000)P2 = ~0x80;
 243   3                  if(current >8000)current =0;
 244   3              }
 245   2              if(keycurrent == 3)
 246   2              {
 247   3      
 248   3              }
 249   2      
 250   2              if(keycurrent == 4)
 251   2              {
 252   3                  if(solar <100){LED[0] = 10;LED[7]=0;LED[6]=0;LED[5]=0;LED[4]=0;LED[3]=0;LED[2]=0;LED[1]=0;}
 253   3                  else if (solar>=100 && solar <200)
 254   3                  {
 255   4                  LED[1] = 10;
 256   4                  LED[0] = 6;                
 257   4                  }
 258   3                  else if (solar>=200 && solar <300)
 259   3                  {
 260   4                  LED[2] = 10;
 261   4                  LED[1] = 6;
 262   4                  LED[0] = 2;                
 263   4                  }
 264   3                  else if (solar>=300 && solar <400)
 265   3                  {
 266   4                  LED[3] = 10;
 267   4                  LED[2] = 6;
 268   4                  LED[1] = 2;   
 269   4                  LED[0] = 0;
 270   4                  }
 271   3                  else if (solar>=400 && solar <500)
 272   3                  {
 273   4                  LED[4] = 10;
 274   4                  LED[3] = 6;
 275   4                  LED[2] = 2;   
 276   4                  LED[1] = 0;
 277   4                  }
 278   3                  else if (solar>=500 && solar <600)
 279   3                  {
 280   4                  LED[5] = 10;
 281   4                  LED[4] = 6;
 282   4                  LED[3] = 2;   
 283   4                  LED[2] = 0;
 284   4                  }
 285   3                  else if (solar>=600 && solar <700)
 286   3                  {
 287   4                  LED[6] = 10;
 288   4                  LED[5] = 6;
 289   4                  LED[4] = 2;   
 290   4                  LED[3] = 0;
 291   4                  }
 292   3                  else if (solar>=700 && solar <800)
 293   3                  {
 294   4                  LED[7] = 10;
 295   4                  LED[6] = 6;
 296   4                  LED[5] = 2;   
 297   4                  LED[4] = 0;
 298   4                  }
 299   3                  else if (solar>=800 && solar <900)
 300   3                  {
 301   4                  LED[7] = 6;
 302   4                  LED[6] = 2;
C51 COMPILER V9.60.0.0   MAIN1                                                             04/14/2023 13:18:57 PAGE 6   

 303   4                  LED[5] = 0; 
 304   4                  }
 305   3                  else if (solar>=900 && solar <1000)
 306   3                  {
 307   4                  LED[6] = 0;
 308   4                  LED[7] = 2;
 309   4                  }
 310   3                  else if (solar>=1000 && solar <1100)
 311   3                  {
 312   4                  LED[7] = 0;                
 313   4                  }
 314   3              }
 315   2          }
 316   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1417    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     34    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
